# Пример конфигурационного файла PyVSB

# Описание формата конфигурационного файла:
# http://www.voidspace.org.uk/python/configobj.html#the-config-file-format

# Путь к корневой директории бэкапа.
backup_root = "/media/var_data/backup/pyvsb"

# Формат архивов, в которых будут храниться файлы бэкапов.
# Допустимые значения: 7z, bz2, gz, tar.
# Значение по умолчанию - bz2.
backup_format = "7z"

# Как только количество бэкапов в текущей группе достигнет данного
# значения, формирование current группы будет завершено.
# 0 - неограниченное количество.
# Значение по умолчанию - 30.
backups_per_group = 8

# Как только количество групп превысит данное значение, старые группы будут
# удалены, так чтобы осталось groups_per_backup_root групп.
# 0 - неограниченное количество.
# Значение по умолчанию - 0.
groups_per_backup_root = 2


# Отправлять отчеты при завершении бэкапа на email адрес.
# Значение по умолчанию - no.
send_email_report = yes
# Email, на который будут отсылаться отчеты.
mail_to = "Konishchev Dmitry <to@mail.com>"
# Поле From отправляемого письма (необязательная опция, если ваша программа
# отправки email сама заполняет это поле).
mail_from = "Konishchev Dmitry <from@mail.com>"
# Программа, с помощью которой будет отправляться email сообщение.
# Значение по умолчанию - "".
mail_program = "msmtp --read-recipients"


# Синтаксис определения элементов бэкапа:
# -->
	# Элемент бэкапа "/bin"
#	[ "/bin" ]
	   	# Программа, которая будет запущена перед бэкапом данного элемента.
#		start_before = ""
	   	# Программа, которая будет запущена после бэкапа данного элемента.
#		start_after = ""
	
		# Фильтры, которые будут применены к файлам и директориям данного
		# элемента бэкапа. Каждый фильтр должен начинаться с символов "+",
		# "-" или "#". Все остальные символы - это регулярное выражение
		# (или комментарий в случае "#"). Синтаксис регулярных выражений -
		# http://docs.python.org/lib/re-syntax.html.
		#
		# Перед бэкапом файла (директории) его путь сравнивается с данными
		# регулярными выражениями. Выполняется команда первого фильтра, под
		# который подошел путь:
		#  "+" - сделать резервную копию
		#  "-" - пропустить файл (директорию)
		# Сравнение с регулярным выражением происходит не по полному пути к
		# файлу (директории), а по пути относительно данного элемента
		# бэкапа. К примеру, если элемент бэкапа - /home/user, а файл -
		# /home/user/firefox/cache, то регулярное выражение будет
		# сравниваться с user/firefox/cache.
#		filters = ""

		# Действие, которое будет применено к файлу, если он не подойдет ни
		# под один фильтр.
#		filter_default_policy = "+"
# <--


[ "/etc" ]
[ "/root/scripts" ]
[ "/var/spool/cron/crontabs" ]


[ "/home/dmitry" ]
	filters = """
		# Отфильтровываем директории, которые занимают много места и не
		# нуждаются в резервном копировании.
		-^dmitry/.cache$
		-^dmitry/.gvfs$
		-^dmitry/.kde/share/apps/ktorrent$
		-^dmitry/.liferea
		-^dmitry/.mozilla/firefox/[^/]+/Cache$
		-^dmitry/.mozilla/plugins$
		-^dmitry/.stardict$
		-^dmitry/.thumbnails$
		-^dmitry/.VirtualBox$
		-^dmitry/.wine$
	"""


[ "/my_files/scripts"]


[ "/my_files/other/private" ]
	filters = """
		# Бэкапим только /my_files/other/private/*_backup
		+^private(/[^/]+_backup(/.+){0,1}){0,1}$
	"""

	filter_default_policy = "-"


[ "/my_files/dirs_tree" ]
	# Если бэкапить директорию нет возможности вследствие ее большого
	# размера, то можно сохранить хотя бы список всех ее файлов и
	# каталогов, чтобы в случае повреждения можно было восстановить их по
	# именам, если эти файлы не уникальны (скачать в интернете и т. п.).
	start_before = "tree -a --dirsfirst /my_files > /my_files/dirs_tree"

	start_after = "rm -f /my_files/dirs_tree"

